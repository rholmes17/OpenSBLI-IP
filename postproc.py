# Python 3
# Interpret files generated by the processing and simulation programs and
# convert into usable data and plots

import plot
import settings
import csv

arguments = settings.getSimArgs()


class RunData:
    def __init__(self):
        self.args = []

        self.t = []
        self.Enstrophy = []
        self.KE = []
        self.KEDR = []

        self.wallTime = 0


# Open file determined to compare results to and return the data from it
def CollectBenchmarkData():
    t = []
    enstrophy = []
    KE = []
    KEDR = []
    with open(arguments.benchmarkFile) as f:
        data_list = list(csv.reader(f))
        for i in range(1, len(data_list)):
            t.append(float(data_list[i][10]))
            enstrophy.append(float(data_list[i][11]))
            KE.append(float(data_list[i][12]))
            KEDR.append(float(data_list[i][13]))
    dKE_dt = plot.DerKE(t, KE)
    return enstrophy, KEDR, dKE_dt


# Valid error types: Self, BenchEnst, BenchKEDR, BenchdKE_dt
def ProcessRunData(errorType="Self", makePlot=False, perfRun=False,
                   plotOrders=[], plotGrid=0):
    time = []
    error = []
    order = []
    coreCount = []
    runId = []
    grid = []
    timeTaken = 0

    consecutivePlotTime = []
    consecutivePlotKEDR = []
    consecutivePlotDKE = []
    consecutivePlotError = []

    currentRun = RunData()

    with open(arguments.dataLog, 'r') as f:
        data_list = list(csv.reader(f))

        # Initialise first run of data
        for i in range(10):
            currentRun.args.append(float(data_list[1][i]))

        # Iterate through all rows excluding headers
        for i in range(1, len(data_list)+1):
            rowSettings = []
            if i < len(data_list):
                for j in range(10):
                    rowSettings.append(float(data_list[i][j]))

            # print(f"Current = {currentRun.args}")
            # print(f"New = {rowSettings}")

            # Check if still reading data from the same run
            if currentRun.args == rowSettings and i != len(data_list):
                # print(f"raw time ={data_list[i][10]}")
                currentRun.t.append(float(data_list[i][-4]))
                currentRun.Enstrophy.append(float(data_list[i][-3]))
                currentRun.KE.append(float(data_list[i][-2]))
                currentRun.KEDR.append(float(data_list[i][-1]))
                # print(f"Stored time = {currentRun.t}")
            else:
                print("new run")

                # Open file with timing data
                with open(arguments.timingLog, 'r') as tf:
                    print(f"Opening timing file {arguments.timingLog}")
                    reader = csv.reader(tf)

                    # Iterate through rows
                    for k, row in enumerate(reader):
                        # Ignore headers
                        if k > 0:
                            # Decide whether current run coincides with
                            # row in the timing log
                            equal = True
                            for j in range(len(currentRun.args)):
                                if float(row[j]) != currentRun.args[j]:
                                    equal = False
                                    break

                            # If it is the same run then store its walltime
                            if equal:
                                print(f"Wall Time is {row[-1]}s")
                                currentRun.wallTime = float(row[-1])
                                grid.append(int(row[9]))
                                coreCount.append(int(row[-4]))
                                runId.append(int(row[0]))

                                timeTaken += float(row[-1])

                # Update list of wall times
                time.append(currentRun.wallTime)

                # If it was a run to measure performance then error is not needed
                if not perfRun:

                    # Obtain data from benchmark run
                    enstBench, KEDRBench, dKE_dtBench = CollectBenchmarkData()

                    # Calculate derivative of kinetic energy
                    dKE_dt = plot.DerKE(currentRun.t, currentRun.KE)

                    # Calculate the error for the given metric (errorType)
                    errorsum, errorList = plot.calc_error(
                        currentRun.t,
                        dKE_dt,
                        currentRun.KEDR,
                        currentRun.Enstrophy,
                        dKE_dtBench,
                        KEDRBench,
                        enstBench,
                        errorType)

                    error.append(errorsum)

                order.append(int(currentRun.args[8]))
                print(f"Order = {currentRun.args[8]}")

                # Plot error
                if errorType == "Self" and makePlot:
                    plot.plot_error(currentRun.t, errorList,
                                    currentRun.KEDR, dKE_dt)

                # check whether data is wanted to plot side-by-side orders
                if order[-1] in plotOrders and grid[-1] == plotGrid:
                    consecutivePlotTime.append(currentRun.t[:])
                    consecutivePlotKEDR.append(currentRun.KEDR[:])
                    consecutivePlotDKE.append(dKE_dt[:])
                    consecutivePlotError.append(errorList[:])
                    print(consecutivePlotTime == currentRun.t)

                currentRun.args = rowSettings
                del currentRun.t[:]
                del currentRun.Enstrophy[:]
                del currentRun.KE[:]
                del currentRun.KEDR[:]

                # print(currentRun.t)
                # print(f"Iterator = {i}")
                # print(f"new time ={data_list[i][10]}")
                if i < len(data_list):
                    currentRun.t.append(float(data_list[i][-4]))
                    currentRun.Enstrophy.append(float(data_list[i][-3]))
                    currentRun.KE.append(float(data_list[i][-2]))
                    currentRun.KEDR.append(float(data_list[i][-1]))

    # Check if data has been stored to generate plots
    if consecutivePlotTime:
        plot.plot_consecutive_error(consecutivePlotTime, consecutivePlotError,
                                    consecutivePlotKEDR, consecutivePlotDKE,
                                    plotOrders)

    
    formattedTime = plot.FormatTime(timeTaken)

    print(f"Total wall clock time for this batch was {timeTaken}s")

    print(f"{int(formattedTime[0])} days, ", end="")
    print(f"{int(formattedTime[1])} hours, ", end="")
    print(f"{int(formattedTime[2])} minutes, ", end="")
    print(f"and {formattedTime[3]: .2f} seconds")
    return time, error, order, coreCount, runId, grid


# time, error, order, coreCount, runId, grid = ProcessRunData(
#     makePlot=False, perfRun=False, plotOrders=[2, 4, 26, 28], plotGrid=0)
# time, error, order, coreCount, runId, grid = ProcessRunData("BenchEnst")
# time, error, order, coreCount, runId, grid = ProcessRunData("BenchKEDR")
time, error, order, coreCount, runId, grid = ProcessRunData("BenchdKE_dt")

plot.plot_cost(time, error, order, xlog=True, ylog=True)
# plot.plot_order(error, order, grid, ylog=True, xlog=False)
# plot.plot_cores(coreCount, time, order)
